# Copyright (C) 2021 Greenbone Networks GmbH
# Some text descriptions might be excerpted from (a) referenced
# source(s), and are Copyright (C) by the respective right holder(s).
#
# SPDX-License-Identifier: GPL-2.0-or-later
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

if(description)
{
  script_oid("1.3.6.1.4.1.25623.1.0.117840");
  script_version("2021-12-17T14:03:21+0000");
  script_cve_id("CVE-2002-20001");
  script_tag(name:"last_modification", value:"2021-12-17 14:03:21 +0000 (Fri, 17 Dec 2021)");
  script_tag(name:"creation_date", value:"2021-12-16 10:47:19 +0000 (Thu, 16 Dec 2021)");
  script_tag(name:"cvss_base", value:"5.0");
  script_tag(name:"cvss_base_vector", value:"AV:N/AC:L/Au:N/C:N/I:N/A:P");
  script_tag(name:"severity_vector", value:"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H");
  script_tag(name:"severity_origin", value:"NVD");
  script_tag(name:"severity_date", value:"2021-11-16 15:36:00 +0000 (Tue, 16 Nov 2021)");
  script_name("Diffie-Hellman Ephemeral Key Exchange DoS Vulnerability (SSL/TLS, D(HE)ater)");
  script_copyright("Copyright (C) 2021 Greenbone Networks GmbH");
  script_category(ACT_GATHER_INFO);
  script_family("Denial of Service");
  script_dependencies("secpod_ssl_ciphers.nasl");
  script_mandatory_keys("secpod_ssl_ciphers/supported_ciphers", "ssl_tls/port");

  script_xref(name:"URL", value:"https://www.researchgate.net/profile/Anton-Stiglic-2/publication/2401745_Security_Issues_in_the_Diffie-Hellman_Key_Agreement_Protocol");
  script_xref(name:"URL", value:"https://github.com/Balasys/dheater");

  script_tag(name:"summary", value:"The remote SSL/TLS server is supporting Diffie-Hellman ephemeral
  (DHE) Key Exchange algorithms and thus could be prone to a denial of service (DoS)
  vulnerability.");

  script_tag(name:"vuldetect", value:"Checks the supported cipher suites of the remote SSL/TLS
  server.");

  script_tag(name:"insight", value:"The Diffie-Hellman Key Agreement Protocol allows remote
  attackers (from the client side) to send arbitrary numbers that are actually not public keys, and
  trigger expensive server-side DHE modular-exponentiation calculations, aka a D(HE)ater attack. The
  client needs very little CPU resources and network bandwidth. The attack may be more disruptive in
  cases where a client can require a server to select its largest supported key size. The basic
  attack scenario is that the client must claim that it can only communicate with DHE, and the
  server must be configured to allow DHE.");

  script_tag(name:"solution", value:"- DHE key exchange should be disabled if no other mitigation
  mechanism can be used and either elliptic-curve variant of Diffie-Hellman (ECDHE) or RSA key
  exchange is supported by the clients. The fact that RSA key exchange is not forward secret should
  be considered.

  - Limit the maximum number of concurrent connections in e.g. the configuration of the remote
  server. For Postfix this limit can be configured via 'smtpd_client_new_tls_session_rate_limit'
  option, for other products please refer to the manual of the product in question on configuration
  possibilities.");

  script_tag(name:"qod_type", value:"remote_banner_unreliable");
  script_tag(name:"solution_type", value:"Mitigation");

  exit(0);
}

include("ssl_funcs.inc");

cipherText = "'DHE' cipher suites";

if( ! port = tls_ssl_get_port() )
  exit( 0 );

if( ! sup_ssl = get_kb_item( "tls/supported/" + port ) )
  exit( 0 );

if( "SSLv3" >< sup_ssl ) {
  sslv3CipherList = get_kb_list( "secpod_ssl_ciphers/sslv3/" + port + "/supported_ciphers" );

  if( ! isnull( sslv3CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    sslv3CipherList = sort( sslv3CipherList );

    foreach sslv3Cipher( sslv3CipherList ) {
      if( sslv3Cipher =~ "^TLS_DHE_.+" ) {
        sslv3Vuln = TRUE;
        sslv3tmpReport += sslv3Cipher + '\n';
      }
    }

    if( sslv3Vuln ) {
      report += cipherText +' accepted by this service via the SSLv3 protocol:\n\n' + sslv3tmpReport + '\n';
    }
  }
}

if( "TLSv1.0" >< sup_ssl ) {
  tlsv1_0CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_0CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_0CipherList = sort( tlsv1_0CipherList );

    foreach tlsv1_0Cipher( tlsv1_0CipherList ) {
      if( tlsv1_0Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_0Vuln = TRUE;
        tlsv1_0tmpReport += tlsv1_0Cipher + '\n';
      }
    }

    if( tlsv1_0Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.0 protocol:\n\n' + tlsv1_0tmpReport + '\n';
    }
  }
}

if( "TLSv1.1" >< sup_ssl ) {
  tlsv1_1CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1_1/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_1CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_1CipherList = sort( tlsv1_1CipherList );

    foreach tlsv1_1Cipher( tlsv1_1CipherList ) {
      if( tlsv1_1Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_1Vuln = TRUE;
        tlsv1_1tmpReport += tlsv1_1Cipher + '\n';
      }
    }

    if( tlsv1_1Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.1 protocol:\n\n' + tlsv1_1tmpReport + '\n';
    }
  }
}

if( "TLSv1.2" >< sup_ssl ) {
  tlsv1_2CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1_2/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_2CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_2CipherList = sort( tlsv1_2CipherList );

    foreach tlsv1_2Cipher( tlsv1_2CipherList ) {
      if( tlsv1_2Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_2Vuln = TRUE;
        tlsv1_2tmpReport += tlsv1_2Cipher + '\n';
      }
    }

    if( tlsv1_2Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.2 protocol:\n\n' + tlsv1_2tmpReport + '\n';
    }
  }
}

if( "TLSv1.3" >< sup_ssl ) {
  tlsv1_3CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1_3/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_3CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_3CipherList = sort( tlsv1_3CipherList );

    foreach tlsv1_3Cipher( tlsv1_3CipherList ) {
      if( tlsv1_3Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_3Vuln = TRUE;
        tlsv1_3tmpReport += tlsv1_3Cipher + '\n';
      }
    }

    if( tlsv1_3Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.3 protocol:\n\n' + tlsv1_3tmpReport + '\n';
    }
  }
}

if( report ) {
  security_message( port:port, data:report );
  exit( 0 );
}

exit( 99 );